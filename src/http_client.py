import socketimport sysimport timefrom urllib.parse import urlparseimport pickleimport osfrom cmd_parser import configure_parser, HTTPArgsfrom tqdm.auto import tqdmpath = os.path.dirname(os.path.realpath(__file__))cookies_path = os.path.join(path, 'cookies.pickle')def make_request(args: HTTPArgs):    url, method, headers, body, timeout, output_file = (        args.url, args.method, args.headers, args.body, args.timeout,        args.output)    if method not in ["GET", 'PUT', 'POST', 'OPTIONS', "HEAD", "PATCH",                      "DELETE", "TRACE", "CONNECT"]:        raise ValueError("Incorrect method")    hostname, port, path = process_url(url)    headers = process_headers(headers)    add_cookie(headers, hostname)    headers['Host'] = f'{hostname}:{port}'    headers['Connection'] = 'close'    body = process_body(body)    request = build_request(body, headers, method, path)    try:        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:            sock.settimeout(timeout)            sock.connect((hostname, port))            sock.sendall(request.encode())            headers, response = read_headers(sock)            content_length = find_content_length(headers)            set_cookie(headers.decode(), hostname)            if output_file:                with open(output_file, 'w') as file:                    process_response(sock, response,                                     content_length, headers, file)            else:                process_response(sock, response,                                 content_length, headers, None)    except TimeoutError:        print("Problems with connection, timeout")        sys.exit(1)    except PermissionError:        print("Not enough permissions to open this file")        sys.exit(1)    except IsADirectoryError:        print("Can't open directory, i need file")        sys.exit(2)    except IOError:        print("An error occurred while recording, please, try again")        sys.exit(1)    except MemoryError:        print("Not enough memory to write to file")        sys.exit(1)def process_response(sock: socket.socket, response: bytes, content_length: int,                     headers: bytes, output_file):    with tqdm(total=content_length, initial=len(response),              unit='B', unit_scale=True, ncols=80,              bar_format='{l_bar}{bar}| {n_fmt}/{total_fmt} [{'                         'percentage:3.0f}%]',              leave=True, position=0) as pbar:        tqdm.write(headers.decode() + "\r\n\r\n", output_file)        for chunk in receive_response(sock):            response += chunk            pbar.update(len(chunk))            tqdm.write(chunk.decode(), output_file)    return responsedef build_request(body, headers, method, path):    method = method.upper()    headers = ''.join([': '.join(header) +                       '\r\n' for header in headers.items()])    return (f'{method} {path} HTTP/1.1\r\n' + headers + "\r\n" + body            + '\r\n\r\n')def process_url(url):    if not url.startswith('http://'):        url = 'http://' + url    url = urlparse(url)    hostname = url.hostname    port = url.port if url.port else 80    path = url.path if url.path else '/'    path = path + '?' + url.query if url.query else path    return hostname, port, pathdef process_headers(headers):    if not headers:        return {}    return dict([x.strip(" '") for x in header.split(':', 1)]                for header in headers)def process_body(body):    if body.startswith('@'):        with open(body[1:], 'r') as file:            body = file.read()    return bodydef receive_response(sock):    while True:        chunk = sock.recv(1024)        if not chunk:            break        yield chunkdef find_content_length(headers: bytes):    if b"Content-Length" not in headers:        print("No content in response")        return 0    return int(headers.split(b"Content-Length: ")[1]               .split(b"\r\n", 1)[0])def read_headers(sock: socket.socket):    response = b""    while True:        response += sock.recv(1000)        if b"\r\n\r\n" in response:            pair = response.split(b"\r\n\r\n", 1)            headers = pair[0]            other = b""            if len(pair) > 1:                other = pair[1]            return headers, otherdef set_cookie(response: str, host: str) -> None:    lines = response.split('\n')    cookie_headers = list(filter(lambda x: x.startswith('Set-Cookie:'), lines))    values = {}    for cookie in cookie_headers:        name, value = cookie.split(': ', 1)[1].split('=', 1)        if name.startswith("__Secure-"):            name = name[9:]        elif name.startswith('__Host-'):            name = name[7:]        values[name] = value    cookies = get_cookies_from_file()    cookies[host] = values    with open(cookies_path, "wb") as file:        pickle.dump(cookies, file)def get_cookies_from_file() -> dict:    cookies = {}    if os.path.exists(cookies_path):        with open(cookies_path, "rb") as file:            cookies = pickle.load(file)        if cookies is not dict:            os.remove(cookies_path)    return cookiesdef add_cookie(headers: dict, host: str) -> None:    cookies = get_cookies_from_file()    if not cookies or host not in cookies:        return    for name, value in cookies[host].items():        headers["Cookies"] = f"{name}={value}"if __name__ == '__main__':    parser = configure_parser()    args = parser.parse_args()    make_request(args)